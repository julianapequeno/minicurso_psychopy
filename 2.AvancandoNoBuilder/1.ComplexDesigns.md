## Designs complexos no Psychopy

Bom agora j√° sabemos os componentes b√°sicos que comp√µem esse software, sabemos como criar uma rotina, sabemos como alterar as configura√ß√µes do programa, como adicionar loops, utilizar vari√°veis, brincar com o Code Component...Perfeito!! Sabemos muita coisa! E o que podemos fazer com tudo isso?

J√° pensou sobre aqueles experimentos que aumenta a dificuldade de acordo com o n√∫mero de acertos da pessoa? Por exempo, testes de nivelamento de ingl√™s. Como a gente implementaria isso no Psychopy? Pense um pouco sobre isso.
....
J√° pensou? üòú Ent√£o vou compartilhar como eu pensei: Talvez, utilizando vari√°veis e a funcionalidade de desabilitar componentes conseguir√≠amos. Talvez um vari√°vel como contador.
> Vari√°vel de estilo _contador_ √© uma vari√°vel que serve para contabilizar quantas vezes o programa passou por determinado ponto do programa. Por exemplo, contar quantas vezes a pessoa acertou.
```python
# inicializa o contador no in√≠cio do c√≥digo, em `Begin Experiment`
contador = 0

# verifica dentro do loop, ent√£o cada vez que o participante acertar
# o contador vai aumentar 1.
# em `Begin Routine`
if key.corr == 1:
    contador = contador + 1
else:
    ...

# no final podemos imprimir o valor de contador
print(contador)
```

Bom, e se eu dissesse que existe uma forma muito maiss _chique_ e _psychopiana_ de se realizar isso? N√≥s iremos conhecer alguns modelos de designs complexos durante este m√≥dulo. Estes modelos s√£o: o **Counterbalanced**, **Randomised block designs**, **Branched designs** e **Adaptive designs**.

Vamos conhecer o **counterbalaced** primeiro.


### Retomando...
Retomando o conceito e `bloco de trials`, temos esta planilha onde cada coluna representa uma vari√°vel que muda a cada _trial_  e cada linha √© uma _trial_.

| arrow_orientation | target_x | correct_keypress | condition |
| --- |  --- | --- | --- |
| 90 | 0.5 | right |valid |
| 270 | -0.5 | left | valid |
| 90 | -0.5 | left  | invalid |
| 270 | 0.5 |right | invalid|


Ent√£o, eu irei mudar algumas coisas. Vou criar mais duas planilhas, uma apenas com os `valid_trials`, as que est√£o na posi√ß√£o correta, e outra com os `invalid_trials`. 

| arrow_orientation | target_x | correct_keypress | condition |
| --- |  --- | --- | --- |
| 90 | 0.5 | right |valid |
| 270 | -0.5 | left | valid |
| 90 | 0.5 | right |valid |
| 270 | -0.5 | left | valid |

| arrow_orientation | target_x | correct_keypress | condition |
| --- |  --- | --- | --- |
| 90 | -0.5 | left  | invalid |
| 270 | 0.5 |right | invalid|
| 90 | -0.5 | left  | invalid |
| 270 | 0.5 |right | invalid|

E agora, uma planilha listando as duas anteriores (como fizemos no m√≥dulo passado)

| block_file |
| ----- |
| valid_trials.csv |
| invalid_trials.csv |


Agora, repetimos todo o processo de cria√ß√£o de um `nested loop`, como fizemos no m√≥dulo passado.  Esse j√° √© o primeiro block design, o `Randomised block design`, basta colocar o loop como `Random` e aleatorizar a ordem dos blocos.

> N√£o irei detalhar isso aqui porque j√° foi visto anteriormente e vou focar no novo conte√∫do, okay? Qualquer coisa volta para o m√≥dulo anterior e confere o passo a passo da cria√ß√£o desse loop aninhado! 