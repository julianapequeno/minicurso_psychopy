## Designs complexos no Psychopy

Bom agora j√° sabemos os componentes b√°sicos que comp√µem esse software, sabemos como criar uma rotina, sabemos como alterar as configura√ß√µes do programa, como adicionar loops, utilizar vari√°veis, brincar com o Code Component...Perfeito!! Sabemos muita coisa! E o que podemos fazer com tudo isso?

J√° pensou sobre aqueles experimentos que aumenta a dificuldade de acordo com o n√∫mero de acertos da pessoa? Por exempo, testes de nivelamento de ingl√™s. Como a gente implementaria isso no Psychopy? Pense um pouco sobre isso.
....
J√° pensou? üòú Ent√£o vou compartilhar como eu pensei: Talvez, utilizando vari√°veis e a funcionalidade de desabilitar componentes conseguir√≠amos. Talvez um vari√°vel como contador.
> Vari√°vel de estilo _contador_ √© uma vari√°vel que serve para contabilizar quantas vezes o programa passou por determinado ponto do programa. Por exemplo, contar quantas vezes a pessoa acertou.
```python
# inicializa o contador no in√≠cio do c√≥digo, em `Begin Experiment`
contador = 0

# verifica dentro do loop, ent√£o cada vez que o participante acertar
# o contador vai aumentar 1.
# em `Begin Routine`
if key.corr == 1:
    contador = contador + 1
else:
    ...

# no final podemos imprimir o valor de contador
print(contador)
```

Bom, e se eu dissesse que existe uma forma muito maiss _chique_ e _psychopiana_ de se realizar isso? N√≥s iremos conhecer alguns modelos de designs complexos durante este m√≥dulo. Estes modelos s√£o: o **counterbalaced**, **Randomised block designs**, **Branched designs** e **Adaptive designs**.

Vamos conhecer o **counterbalaced** primeiro.


### Retomando...
Retomando o conceito e `bloco de trials`, temos esta planilha onde cada coluna representa uma vari√°vel que muda a cada _trial_  e cada linha √© uma _trial_.

| arrow_orientation | target_x | correct_keypress | condition |
| --- |  --- | --- | --- |
| 90 | 0.5 | right |valid |
| 270 | -0.5 | left | valid |
| 90 | -0.5 | left  | invalid |
| 270 | 0.5 |right | invalid|


Ent√£o, eu irei mudar algumas coisas. Vou criar mais duas planilhas, uma apenas com os `valid_trials`, as que est√£o na posi√ß√£o correta, e outra com os `invalid_trials`. 

| arrow_orientation | target_x | correct_keypress | condition |
| --- |  --- | --- | --- |
| 90 | 0.5 | right |valid |
| 270 | -0.5 | left | valid |
| 90 | 0.5 | right |valid |
| 270 | -0.5 | left | valid |

| arrow_orientation | target_x | correct_keypress | condition |
| --- |  --- | --- | --- |
| 90 | -0.5 | left  | invalid |
| 270 | 0.5 |right | invalid|
| 90 | -0.5 | left  | invalid |
| 270 | 0.5 |right | invalid|

E agora, uma planilha listando as duas anteriores (como fizemos no m√≥dulo passado)

| block_file |
| ----- |
| valid_trials.csv |
| invalid_trials.csv |


Agora, repetimos todo o processo de cria√ß√£o de um `nested loop`, como fizemos no m√≥dulo passado. 
> N√£o irei detalhar isso aqui porque j√° foi visto anteriormente e vou focar no novo conte√∫do, okay? Qualquer coisa volta para o m√≥dulo anterior e confere o passo a passo da cria√ß√£o desse loop aninhado! 

### Counterbalaced design
O **Counterbalaced** √© um design que permite que voc√™ divida os participantes em grupos e defina uma ordem diferente de blocos de _trials_ para cada um. Por exemplo, o grupo A inicia vendo o bloco X e depois v√™ o Y, enquanto o grupo B inicia vendod o Y e depois v√™ o X.

Para construir esse tipo de design utilizando o exemplo dado anteriormente, √© necess√°rio que: 
- Se crie um arquivo representando cada grupo: `grupoA.csv` e `grupoB.csv`.
- Liste a ordem dos blocos de trials que cada grupo ver√°. Nesse caso as planilhas ficar√£o assim:
    - `grupoA.csv`
        
        | blocks |
        | ------ |
        | valid_trials.csv |
        | invalid_trials.csv |
    
    - `grupoB.csv`

        | blocks |
        | --- |
        | invalid_trials.csv |
        | valid_trials.csv |
- Adicione o campo `group` no `Experiment Settings` com o valor de `['A','B']`. Isso ir√° resultar em um _drop down_ para que voc√™ escolha no in√≠cio do experimento se o participante √© do grupo A ou do grupo B.
- Atualize o seu looop `blocks` (o mais externo). No campo `Conditions` ao inv√©s de darmos uma planilha que tem listada o nome das planilhas `groupX.csv` (isso requeriria um terceiro loop), iremos utilizar de `vari√°veis` e de conceitos de `string` e `concatena√ß√£o de strings`! 

#### O que √© uma string?
Uma `String` na computa√ß√£o √© a representa√ß√£o de uma sequ√™ncia de caracteres. √â usualmente utilizada para guardar textos, frases e palavras em um programa. Por exemplo, esse par√°grafo √© uma string!
A `String` √© um `tipo` de vari√°vel. Os `tipos` s√£o o que diferenciam uma vari√°vel de outra e restrigem seu uso para determinadas aplica√ß√µes. Por exemplo, `x = 10` e `nome= "juliana"` s√£o duas vari√°veis, mas se n√£o definirmos o seu tipo, algo assim seria poss√≠vel:
```python
x = 10
nome = "Juliana"

x + nome
```
Qual √© o resultado disso? Sem pensar na l√≥gica de programa√ß√£o, mas para n√≥s mesmos. Se voc√™ perguntar √† sua professora de matem√°tica, o que ela responderia? 

Ent√£o, se criou o `tipo`, nesse caso o `x` poderia ser do tipo `inteiro`, cobre n√∫meros que pertencem √† classe dos inteiros at√© um limite (devido ao limite de capacidade do computador). Enquanto o `nome` √© do tipo `String`, dado que √© um texto.


Agora, e se eu quiser unir duas strings? 
```python
inicio = "Ol√°, "
nome = "Juliana"
```

Podemos realizar a opera√ß√£o de _concatena√ß√£o de strings_, essa √© uma opera√ß√£o que une os dois textos em um s√≥. Em python, ela √© representada pelo uso do `+`.

Ent√£o, voltando ao nosso problema, o seu campo `Conditions` ficar√° com da seguinte forma:

```python
$ 'group' + expInfo['group'] + '.csv'
```
- Colocamos o `$` por se tratar de uma vari√°vel.
- Note que os nomes dos nosso dois arquivos come√ßam com 'group', `groupA.csv` e `groupB.csv`. Logo, iniciamos com uma `String` com o valor `'group'`.
- Concatenamos essa string com o resultado que o participante ou o pesquisador preencheu antes de iniciar o experimento. Isto √©, nos dados iniciais, o campo que informa se o participante √© do grupo A ou do grupo B. As informa√ß√µes do experimento s√£o representados por uma estrutura de dados em python chamada `Dicion√°rio`, assim conseguimos captar o resultado escolhido acessando o campo `group`. Logo `expInfo['group']`, ter√° como valor `A` ou `B`, depende da entrada que o usu√°rio forneceu.
- Concatenamos com o tipo do arquivo `'.csv'`, e ent√£o enfim temos o nome/caminho do arquivo. Lembre que todos que arquivos devem estar na mesma pasta onde o arquivo do projeto est√° para que isso funcione!!

    > E se n√£o estiver? Bom, antes de inserir o que acabei de explicar, coloque uma string que tenha o caminho at√© a pasta em que o arquivo est√°. Por exemplo:
    ```python
        $'/home/juliana/Documentos/' +'group' + expInfo['group'] + '.csv'
    ```

Determine o `loopType` como `Sequential`, para que ele siga a ordem que voc√™ definiu no arquivo.